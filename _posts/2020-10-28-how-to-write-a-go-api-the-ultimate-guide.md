---
layout: post
title:  "How to write a Go API: The Ultimate Guide"
categories: []
tags:
- go
- golang
- api
- programming
- software development
- repo
- ultimate guide
- dockertest
- chi
- swagger
- structured logging
- best practices
- how to
status: publish
type: post
published: true
meta: {}
---
<img src="/assets/posts/gopher.svg" width="35%" align="right" style="margin: 15px" />

"TIL" ([today I learned](https://www.urbandictionary.com/define.php?term=TIL)) is an acronym I recently discovered (Example usage: "TIL what TIL means"). Since I'm ESL ([English as Second Language](https://www.urbandictionary.com/define.php?term=ESL)) I use the urban dictionary a lot to look up these acronyms. "TIL" turned out to be a very useful term, because it's true: One never stops learning. And so it happened that I started this blog writing about [a Python Flask API](/blog/python-flask-base-project) and continued with a three part series on [how to write a go API](/blog/how-to-write-a-go-api-part-1-webserver-with-iris). And while there is a lot of valuable information in those posts, today I am writing about what I learned since then and what my current set of best practices is to write an efficient and production ready API.

Reading many blogs myself, I sometimes miss context on given examples. So I published a sample repo which can be found on [github](https://jonnylangefeld/go-api). Every code example in this post links to the source lines of this repo.

The following paragraphs feature a large set of best practices and why I like them. Send me an [email](/about#contactform) or tweet me [@jonnylangefeld](https://twitter.com/jonnylangefeld) if you feel like something is missing!

<!--more-->

**Table of Contents**

- [1. Project Scaffolding](#1-project-scaffolding)
- [2. The tools.go Pattern](#2-the-toolsgo-pattern)
- [3. Command Line Flags With pflag](#3-command-line-flags-with-pflag)
- [4. Structured Logging With zap](#4-structured-logging-with-zap)
- [5. Graceful Exits](#5-graceful-exits)
- [6. Log Version on Startup](#6-log-version-on-startup)
- [7. Define Types in Their Own Package](#7-define-types-in-their-own-package)
- [8. chi as HTTP Framework](#8-chi-as-http-framework)
- [9. Custom Middlewares](#9-custom-middlewares)
- [10. Pagination](#10-pagination)
- [11. Database Integration With gorm](#11-database-integration-with-gorm)
- [12. Database Integration Tests With dockertest](#12-database-integration-tests-with-dockertest)
- [13. API Integration Tests With gomock](#13-api-integration-tests-with-gomock)
- [14. Render Responses With go-chi/render](#14-render-responses-with-go-chirender)
- [15. Documentation as Code With http-swagger](#15-documentation-as-code-with-http-swagger)
- [16. Staged Dockerfile](#16-staged-dockerfile)

### 1. Project Scaffolding

I use the following tree as project layout. More packages can be added under `pkg`.
```
├── Dockerfile
├── Makefile
├── docs                    # automatically generated by `make docs`
├── go.mod
├── go.sum
├── main.go                 # main.go in the root rather than in `/cmd` directory
├── pkg
│   ├── api                 # containing all API related functions and the router
│   │   ├── api.go
│   │   ├── api_test.go
│   │   └── operations.go
│   ├── db                  # all database interactions happen in here
│   │   ├── db.go
│   │   └── db_test.go
│   ├── middelware          # for custom middlewares
│   │   ├── context.go
│   │   └── logger.go
│   └── types               # our types get a separate package
│       └── types.go
├── readme.md
└── tools.go                # tools.go to manage tool versions via go.mod
```

With that out of the way, lets look into the `main.go` file.

### 2. The tools.go Pattern

I'm really a fan of managing tool dependencies also through go modules. That pins their versions and includes them in my vendor directory. Marco Franssen wrote in-depth about this pattern in [this blog post](https://marcofranssen.nl/manage-go-tools-via-go-modules/).

### 3. Command Line Flags With [pflag](https://github.com/spf13/pflag)

There are many ways to work with command line flags and configurations in go. One can go fancy with [`viper`](https://github.com/spf13/viper) or stay simple with go's built in `flags` package. I like [`pflag`](https://github.com/spf13/pflag) because of it's simplicity and similarity to go's own package, yet it offers POSIX/GNU-style flags making it more natural to use on your command line. The [sample repo](https://jonnylangefeld/go-api) contains an example usage:

```go
func init() {
	pflag.StringVarP(&addr, "address", "a", ":8080", "the address for the api to listen on. Host and port separated by ':'")
	pflag.Parse()
}
```
<sup>(*[source](https://github.com/jonnylangefeld/go-api/blob/v1.0.0/main.go#L22-L25)*)</sup>

Pflag comes with help built in:

```
$ go-api -h
Usage of go-api:
  -a, --address string   the address for the api to listen on. Host and port separated by ':' (default ":8080")

```

### 4. Structured Logging With [zap](https://github.com/uber-go/zap)

This is certainly an opinionated decision, but my favorite logger is [zap](https://github.com/uber-go/zap). It can be configured in all kinds of ways, but I like to keep it very simple. This is the configuration I use:

```go
// configure logger
log, _ := zap.NewProduction(zap.WithCaller(false))
defer func() {
    _ = log.Sync()
}()
```
<sup>(*[source](https://github.com/jonnylangefeld/go-api/blob/v1.0.0/main.go#L34-L38)*)</sup>

Which gives me a beautiful log output like the following:

```json
{"level":"info","ts":1601686510.597971,"msg":"starting up API...","version":"v1.0.0"}
{"level":"info","ts":1601686510.70517,"msg":"ready to serve requests on :8080"}
{"level":"info","ts":1601686516.446462,"msg":"served request","proto":"HTTP/1.1","method":"GET","path":"/articles","lat":0.002087763,"status":200,"size":13,"reqId":"C02C864PLVDL/gESGYmlmCu-000001"}
{"level":"info","ts":1601686521.3242629,"msg":"served request","proto":"HTTP/1.1","method":"GET","path":"/orders","lat":0.002300746,"status":200,"size":13,"reqId":"C02C864PLVDL/gESGYmlmCu-000002"}
{"level":"info","ts":1601686525.5588071,"msg":"gracefully shutting down"}

```

### 5. Graceful Exits

This one is not ultimately necessary but I've seen it a lot and ensures cleanup tasks when the API is shutting down. A graceful exit is implemented by making a channel in the beginning of your program and listening for a certain event, like this one for a keyboard interrupt:

```go
// gracefully exit on keyboard interrupt
c := make(chan os.Signal, 1)
signal.Notify(c, os.Interrupt, syscall.SIGTERM)
```
<sup>(*[source](https://github.com/jonnylangefeld/go-api/blob/v1.0.0/main.go#L30-L32)*)</sup>

At the end of the program, after starting the webserver in a go routine (see #5), we react to the signal:

```go
<-c
log.Info("gracefully shutting down")
os.Exit(0)
```
<sup>(*[source](https://github.com/jonnylangefeld/go-api/blob/v1.0.0/main.go#L58-L61)*)</sup>

### 6. Log Version on Startup

This one is also minor, but it turns out to be very useful to see the version by just reading the logs for debugging. It makes it clear which exact code base ran the code and resulted in a potential error.

The version is injected by using an unset `version` variable in the `main.go` file and setting it via the build command (for instance in your `Makefile`):

```bash
VERSION ?= $(shell git describe --match 'v[0-9]*' --tags --always)

build:
	@go build -ldflags "-X main.version=$(VERSION)"
```
<sup>(*[source](https://github.com/jonnylangefeld/go-api/blob/v1.0.0/Makefile#L1-L4)*)</sup>

In the `main.go` file you can use the version as follows (after instantiating it via `var version string`):


```go
// print current version
log.Info("starting up API...", zap.String("version", version))
```
<sup>(*[source](https://github.com/jonnylangefeld/go-api/blob/v1.0.0/main.go#L40-L41)*)</sup>

### 7. Define Types in Their Own Package

Types should be reusable. Let's say someone was to build a command line interface interacting with your API, they would appreciate if they could just import your API types. So we define types as `struct`s in `pkg/types/types.go` (we will get to the struct tags and the doc strings later):

```go
// Article is one instance of an article
type Article struct {
	// The unique id of this item
	ID int `gorm:"type:SERIAL;PRIMARY_KEY" json:"id" example:"1"`
	// The name of this item
	Name string `gorm:"type:varchar;NOT NULL" json:"name" example:"Skittles"`
	// The price of this item
	Price float64 `gorm:"type:decimal;NOT NULL" json:"price" example:"1.99"`
} // @name Article
```
<sup>(*[source](https://github.com/jonnylangefeld/go-api/blob/v1.0.0/pkg/types/types.go#L10-L18)*)</sup>

### 8. [chi](https://github.com/go-chi/chi) as HTTP Framework

My http framework of choice these days is [go-chi/chi](https://github.com/go-chi/chi) (upon recommendation by [@elsesiy](https://twitter.com/elsesiy) - thank you!) for its light weight, idiomatic implementation, but mainly for its 100% compatibility with `net/http` allowing you to use any existing middleware.

The server is started as go routine and listens on the configured address:

```go
// start the api server
r := api.GetRouter(log, dbClient)
go func() {
    if err := http.ListenAndServe(addr, r); err != nil {
        log.Error("failed to start server", zap.Error(err))
        os.Exit(1)
    }
}()
```
<sup>(*[source](https://github.com/jonnylangefeld/go-api/blob/v1.0.0/main.go#L49-L56)*)</sup>

The router gets configured in the `api` package, setting the db client and the logger:

```go
func GetRouter(log *zap.Logger, dbClient db.ClientInterface) *chi.Mux {
	r := chi.NewRouter()
	r.Use(middleware.RequestID)
	SetDBClient(dbClient)
	if log != nil {
		r.Use(m.SetLogger(log))
	}
	buildTree(r)

	return r
}
```
<sup>(*[source](https://github.com/jonnylangefeld/go-api/blob/v1.0.0/pkg/api/api.go#L31-L41)*)</sup>

The tree of requests looks in code just as it would like in a folder structure. Every sub request is attached to its parent. Here is an example request tree, that handles articles and orders for a store:

```go
func buildTree(r *chi.Mux) {
	r.HandleFunc("/swagger", func(w http.ResponseWriter, r *http.Request) {
		http.Redirect(w, r, r.RequestURI+"/", http.StatusMovedPermanently)
	})
	r.Get("/swagger*", httpSwagger.Handler())

	r.Route("/articles", func(r chi.Router) {
		r.With(m.Pagination).Get("/", ListArticles)

		r.Route("/{id}", func(r chi.Router) {
			r.Use(m.Article)
			r.Get("/", GetArticle)
		})

		r.Put("/", PutArticle)
	})

	r.Route("/orders", func(r chi.Router) {
		r.With(m.Pagination).Get("/", ListOrders)

		r.Route("/{id}", func(r chi.Router) {
			r.Use(m.Order)
			r.Get("/", GetOrder)
		})

		r.Put("/", PutOrder)
	})
}
```
<sup>(*[source](https://github.com/jonnylangefeld/go-api/blob/v1.0.0/pkg/api/api.go#L43-L70)*)</sup>

### 9. Custom Middlewares

In the tree above, you can spot the usage of

```go
		r.Route("/{id}", func(r chi.Router) {
			r.Use(m.Article)
			r.Get("/", GetArticle)
		})
```
<sup>(*[source](https://github.com/jonnylangefeld/go-api/blob/v1.0.0/pkg/api/api.go#L52-L55)*)</sup>

 Custom middlewares live in the `middleware` package. `m` is our custom middleware, imported through

```go
m "github.com/jonnylangefeld/go-api/pkg/middelware"
```
<sup>(*[source](https://github.com/jonnylangefeld/go-api/blob/v1.0.0/pkg/api/api.go#L13)*)</sup>

Custom middlewares are very powerful. They are basically an injection into the sequence of handlers of the api and can do anything 'along the way'. In this instance we know we are in a part of our router tree, that will always require the article object pulled from the database. So we inject a custom middleware, that does exactly that for us and injects it into the context of the request. The context is available through the entire handler chain, so for any succeeding handler our object will be available.

The following middelware is the `http.Handler` we used above via `r.Use(m.Article)` and injects the article object into the context.

```go
// Article middleware is used to load an Article object from
// the URL parameters passed through as the request. In case
// the Article could not be found, we stop here and return a 404.
func Article(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		var article *types.Article

		if id := chi.URLParam(r, "id"); id != "" {
			intID, err := strconv.Atoi(id)
			if err != nil {
				_ = render.Render(w, r, types.ErrInvalidRequest(err))
				return
			}
			article = DBClient.GetArticleByID(intID)
		} else {
			_ = render.Render(w, r, types.ErrNotFound())
			return
		}
		if article == nil {
			_ = render.Render(w, r, types.ErrNotFound())
			return
		}

		ctx := context.WithValue(r.Context(), ArticleCtxKey, article)
		next.ServeHTTP(w, r.WithContext(ctx))
	})
}
```
<sup>(*[source](https://github.com/jonnylangefeld/go-api/blob/v1.0.0/pkg/middelware/context.go#L33-L59)*)</sup>

Later on in our handlers, we just pull the article from the context, without reaching out to the database again. 

```go
func GetArticle(w http.ResponseWriter, r *http.Request) {
	article := r.Context().Value(m.ArticleCtxKey).(*types.Article)

	if err := render.Render(w, r, article); err != nil {
		_ = render.Render(w, r, types.ErrRender(err))
		return
	}
}
```
<sup>(*[source](https://github.com/jonnylangefeld/go-api/blob/v1.0.0/pkg/api/operations.go#L22-L29)*)</sup>

The article object is available for every child in the request tree, which makes these custom middlewares so powerful.

### 10. Pagination

Click [here](/blog/how-to-write-a-go-api-pagination) to read the separate blog post on pagination.

### 11. Database Integration With [gorm](https://github.com/go-gorm/gorm)

In [previous blog posts](/blog/how-to-write-a-go-api-part-2-database-integration) I have described how I use [gorm](https://github.com/go-gorm/gorm) as an object relational mapping framework in go APIs. That has not changed so far. I like the ease of use and the ability to still write raw SQL if I need to. That especially comes in handy if the underlying database is [postgres](https://www.postgresql.org/), which has a bunch of custom features that no ORM would naturally cover. Go check out my [old blog post](/blog/how-to-write-a-go-api-part-2-database-integration) for in-depth coverage.

However, I did change how I interact with the database client. Rather than just using the bare-bone `gorm.Open()` call in the `main()` function, I do write a custom client interface, that wraps the gorm client. The custom client interface features a `Connect()` function to establish the database and a bunch of functions that will be called by the different API endpoints. This interfacing will help us later to write API integration tests with [integration tests with gomock](#13-api-integration-tests-with-gomock).

```go
// ClientInterface resembles a db interface to interact with an underlying db
type ClientInterface interface {
	Ping() error
	Connect(connectionString string) error
	GetArticleByID(id int) *types.Article
	SetArticle(article *types.Article) error
	GetArticles(pageID int) *types.ArticleList
	GetOrderByID(id int) *types.Order
	SetOrder(order *types.Order) error
	GetOrders(pageID int) *types.OrderList
}

// Client is a custom db client
type Client struct {
	Client *gorm.DB
}
```
<sup>(*[source](https://github.com/jonnylangefeld/go-api/blob/v1.0.0/pkg/db/db.go#L17-L32)*)</sup>

This pattern allows us to still access the underlying client if we ever needed to. Now this does create a funny looking construct that looks like `client.Client`, but I've seen this pattern [elsewhere](https://github.com/kubernetes-sigs/controller-runtime/blob/master/pkg/client/client.go#L95) and actually think it is quite useful, to still make lower level function calls available to higher level interfaces.

### 12. Database Integration Tests With [dockertest](https://github.com/ory/dockertest)

Database integration tests are important to be done on a database as close as possible to the one intended to be used in production. That is because databases have many different flavors and they all have their own quirks. Especially for a database like postgres this is important, as postgres offers a lot of custom functions and features, that can't be replicated through other testing methods like dependency injection.

The best way to create a short-lived database, that's just there during testing and always has the same state, is through a docker container. That can be easily run locally and on CI systems and ensures that we interact correctly with the actual database.

Just as the last topic, I have describe this concept in a [blog post last year](/blog/how-to-write-a-go-api-part-3-testing-with-dockertest) and this has probably changed the least since I've blogged about it, so the old post is still accurate. To see how it integrates into the sample repository, check the [`pkg/db/db_test.go` file](https://github.com/jonnylangefeld/go-api/blob/v1.0.0/pkg/db/db_test.go).

### 13. API Integration Tests With [gomock](https://github.com/golang/mock)

[gomock](https://github.com/golang/mock) is a great tool for any kind of integration tests. The basic idea is to mock an interface of another package, so you don't have to set up a dependency just for testing. Imagine a tool that pulls in data from the Google Calendar API, you don't want to be dependent on the Google Calendar API up and running during your integration tests. So you mock the dependency. The assumption here is that the used dependency is itself tested properly. The way this is done is through an interface, for which we can replace functions during our tests.

In the scenario of our [demo go-api](https://github.com/jonnylangefeld/go-api), our API operations depend on the database. That would mean that we need an up and running database for API integration tests. However, we covered proper [database integration tests earlier](#12-database-integration-tests-with-dockertest), so now we can assume those database calls are working properly. And to not also depend on the up and running database during API integration tests, we mock the database calls as follows:

First off, [add gomock to the `tools.go` file](https://github.com/jonnylangefeld/go-api/blob/v1.0.0/tools.go#L6). Then we'll add this section to the api integration tests:

```go
//go:generate $GOPATH/bin/mockgen -destination=./mocks/db.go -package=mocks github.com/jonnylangefeld/go-api/pkg/db ClientInterface

func getDBClientMock(t *testing.T) *mocks.MockClientInterface {
	ctrl := gomock.NewController(t)
	dbClient := mocks.NewMockClientInterface(ctrl)

	dbClient.EXPECT().GetArticles(gomock.Eq(0)).Return(&types.ArticleList{
		Items: []*types.Article{
			&testArticle1,
			&testArticle2,
		},
	})

	dbClient.EXPECT().GetArticles(gomock.Eq(1)).Return(&types.ArticleList{
		Items: []*types.Article{
			&testArticle2,
		},
	})

	dbClient.EXPECT().GetArticleByID(gomock.Eq(1)).Return(&testArticle1).AnyTimes()

	dbClient.EXPECT().SetArticle(gomock.Any()).DoAndReturn(func(article *types.Article) error {
		if article.ID == 0 {
			article.ID = 1
		}
		return nil
	}).AnyTimes()

	return dbClient
}
```
<sup>(*[source](https://github.com/jonnylangefeld/go-api/blob/v1.0.0/pkg/api/api_test.go#L74-L103)*)</sup>

The first line of this section is important, even though commented out. It tells `go generate` (which we will call through a [Makefile target](https://github.com/jonnylangefeld/go-api/blob/v1.0.0/Makefile#L26-L27)) that here is an execution to be done. It means that `mockgen` should mock the `ClientInterface` in the `github.com/jonnylangefeld/go-api/pkg/db` package. It does that by creating a new file (`./mocks/db.go` in this case) with a whole bunch of generated code that is not meant to be touched. But we can now use the mock interface in the form of `mocks.NewMockClientInterface(ctrl)`. All functions of the mocked interface are available in this mock and can now be overwritten with custom logic. In the example above we are responding with different returns for different IDs of the `GetArticles()` function and mock some other functions of the interface as well.

Now once we run the actual API integration tests, we don't initialize the API router with an interface to the actual database, but with the just created mock interface. That way the actual database is never called.

```go
r := GetRouter(nil, getDBClientMock(t))
```
<sup>(*[source](https://github.com/jonnylangefeld/go-api/blob/v1.0.0/pkg/api/api_test.go#L107)*)</sup>

The rest of the API integration tests is less magical and we just use a [helper function](https://github.com/jonnylangefeld/go-api/blob/v1.0.0/pkg/api/api_test.go#L168) to send an http request against an in-memory http server.

```go
body := bytes.NewReader([]byte(test.body))
gotResponse, gotBody := testRequest(t, ts, test.method, test.path, body, test.header)
assert.Equal(t, test.wantCode, gotResponse.StatusCode)
if test.wantBody != "" {
    assert.Equal(t, test.wantBody, gotBody, "body did not match")
}
```
<sup>(*[source](https://github.com/jonnylangefeld/go-api/blob/v1.0.0/pkg/api/api_test.go#L157-L162)*)</sup>

Every test request gets routed to its corresponding API endpoint, which internally calls the functions on the database interface, that we just mocked above.

### 14. Render Responses With [go-chi/render](github.com/go-chi/render)

go-chi comes with a built-in way to render and bind data for your json API. This simplifies our responses to something simple as `render.Render(w, r, article)` and `go-chi/render` will take care of the rest and that it reaches the client in the right format.

```go
func GetArticle(w http.ResponseWriter, r *http.Request) {
	article := r.Context().Value(m.ArticleCtxKey).(*types.Article)

	if err := render.Render(w, r, article); err != nil {
		_ = render.Render(w, r, types.ErrRender(err))
		return
	}
}
```
<sup>(*[source](https://github.com/jonnylangefeld/go-api/blob/v1.0.0/pkg/api/operations.go#L22-L29)*)</sup>

What's happening behind the scenes here is that the `article` object implements the [`go-chi/render.Renderer`](https://github.com/go-chi/render/blob/master/render.go#L9) and [`go-chi/render.Binder`](https://github.com/go-chi/render/blob/master/render.go#L14) interfaces.

```go
// Render implements the github.com/go-chi/render.Renderer interface
func (a *Article) Render(w http.ResponseWriter, r *http.Request) error {
	return nil
}

// Bind implements the the github.com/go-chi/render.Binder interface
func (a *Article) Bind(r *http.Request) error {
	return nil
}
```
<sup>(*[source](https://github.com/jonnylangefeld/go-api/blob/v1.0.0/pkg/types/types.go#L20-L28)*)</sup>

Once these two functions are implemented, you are ready to go and the `article` object can be [rendered](https://github.com/jonnylangefeld/go-api/blob/v1.0.0/pkg/api/operations.go#L22-L29) in responses and [bound](https://github.com/jonnylangefeld/go-api/blob/v1.0.0/pkg/api/operations.go#L43-L46) in `POST` or `PUT` requests.

### 15. Documentation as Code With [http-swagger](https://github.com/swaggo/http-swagger)

The [openapi V3](https://swagger.io/specification/) specification is the industry standard and a great way to document your API for your users. However, you don't want to end up writing an independent yaml or json file, that you have to update anytime you change something in your API.  
On top of that it would be great if other developers working on the code have the same documentation of a given API function available. [http-swagger](https://github.com/swaggo/http-swagger) comes in to fix these problems. The source-of-truth of your API documentation will remain in the docstrings of your handlers, but will be automatically rendered into an openapi spec and displayed via the swagger-ui. Let's look into how it works.

You might have seen docstrings that look similar to this
```go
// GetArticle renders the article from the context
// @Summary Get article by id
// @Description GetArticle returns a single article by id
// @Tags Articles
// @Produce json
// @Param id path string true "article id"
// @Router /articles/{id} [get]
// @Success 200 {object} types.Article
// @Failure 400 {object} types.ErrResponse
// @Failure 404 {object} types.ErrResponse
func GetArticle(w http.ResponseWriter, r *http.Request) {
```
<sup>(*[source](https://github.com/jonnylangefeld/go-api/blob/master/pkg/api/operations.go#L12-L22)*)</sup>

These are a whole bunch of key words, interpreted by [swaggo](https://github.com/swaggo/swag). Check the full documentation [here](https://github.com/swaggo/swag#declarative-comments-format). We are basically collecting all human readable text of the documentation here in the docstring of that handler function and also make links to the possible returned objects. If we change something here, we'll just have to run [`make generate-docs`](https://github.com/jonnylangefeld/go-api/blob/master/Makefile#L9), and we'll get all files in the [`docs`](https://github.com/jonnylangefeld/go-api/tree/master/docs) directory, which includes an openapi json, yaml and some go code, automatically generated. If we want to inject something into the spec, like the current build version, we can do so from the `main` file:

```go
docs.SwaggerInfo.Version = version
```
<sup>(*[source](https://github.com/jonnylangefeld/go-api/blob/master/main.go#L28)*)</sup>

All that's left to do now is expose the swagger UI via an endpoint:

```go
r.HandleFunc("/swagger", func(w http.ResponseWriter, r *http.Request) {
    http.Redirect(w, r, r.RequestURI+"/", http.StatusMovedPermanently)
})
r.Get("/swagger*", httpSwagger.Handler())
```
<sup>(*[source](https://github.com/jonnylangefeld/go-api/blob/master/pkg/api/api.go#L44-L47)*)</sup>

Now once that's all set up, we can access the swagger UI via [http://localhost:8080/swagger](http://localhost:8080/swagger), and we get the fully featured swagger UI for our API:

<img src="/assets/posts/swagger-ui.png" width="100%" align="middle" style="margin: 15px" />

It comes with all the models and even examples that you can add via struct tags like the following:

```go
// Article is one instance of an article
type Article struct {
	// The unique id of this item
	ID int `gorm:"type:SERIAL;PRIMARY_KEY" json:"id" example:"1"`
	// The name of this item
	Name string `gorm:"type:varchar;NOT NULL" json:"name" example:"Skittles"`
	// The price of this item
	Price float64 `gorm:"type:decimal;NOT NULL" json:"price" example:"1.99"`
} // @name Article
```
<sup>(*[source](https://github.com/jonnylangefeld/go-api/blob/master/pkg/types/types.go#L10-L18)*)</sup>

<img src="/assets/posts/swagger-details.png" width="100%" align="middle" style="margin: 15px" />

### 16. Staged Dockerfile

Last but not least, I always recommend to have a staged `Dockerfile` to allow us to use a [distroless](https://github.com/GoogleContainerTools/distroless) executable-stage image. That means your build stage is separated from the actual executable stage and will make your posted image way smaller.

> Restricting what's in your runtime container to precisely what's necessary for your app is a best practice employed by Google and other tech giants that have used containers in production for many years. It improves the signal to noise of scanners (e.g. CVE) and reduces the burden of establishing provenance to just what you need.

<sup>(*[source](https://github.com/GoogleContainerTools/distroless#why-should-i-use-distroless-images)*)</sup>

That means that we build our binary through a docker container via the following:

```docker
FROM golang:1.14 as gobuild
ARG VERSION=latest

WORKDIR /go/src/github.com/jonnylangefeld/go-api
ADD go.mod go.sum main.go ./
ADD vendor ./vendor
ADD pkg ./pkg
ADD docs ./docs

RUN CGO_ENABLED=0 GOOS=linux GO111MODULE=on go build -mod=vendor -o go-api -ldflags "-X main.version=$VERSION" main.go
```
<sup>(*[source](https://github.com/jonnylangefeld/go-api/blob/master/Dockerfile#L1-L10)*)</sup>

And then we just copy that binary over to a distroless docker image:

```docker
FROM gcr.io/distroless/base

COPY --from=gobuild /go/src/github.com/jonnylangefeld/go-api/go-api /bin

ENTRYPOINT ["/bin/go-api"]
```
<sup>(*[source](https://github.com/jonnylangefeld/go-api/blob/master/Dockerfile#L12-L16)*)</sup>
